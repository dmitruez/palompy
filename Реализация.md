Ок, делаю **сухой боевой план**, без воды.
Стек возьму такой (можешь заменить на Python, если хочешь, но логика та же):

* **Backend:** Node.js + TypeScript + Express
* **DB:** PostgreSQL + pgvector
* **AI:** OpenAI (chat + embeddings)
* **Frontend-виджет:** ванильный JS + минимальный CSS
* **Админка:** упрощённо – React или просто server-side шаблоны (по желанию)

---

## ЧАСТЬ 0. Подготовка окружения

**1. Инструменты:**

* Node.js LTS
* PostgreSQL 15+
* Git
* Docker (опционально, но лучше сразу)

**2. Создать репозиторий:**

* `backend/`
* `frontend-widget/`
* `admin-panel/` (по желанию сразу или потом)
* `docker/` (docker-compose и т.п.)

---

## ЧАСТЬ 1. Backend – базовый каркас

**1. Инициализация проекта**

```bash
mkdir backend && cd backend
npm init -y
npm install express cors dotenv pg pg-hstore
npm install openai
npm install zod
npm install typescript ts-node-dev @types/node @types/express --save-dev
npx tsc --init
```

**2. Структура папок**

* `src/`

  * `index.ts` (вход)
  * `config/` (`env.ts`, `db.ts`, `openai.ts`)
  * `routes/` (`shops.ts`, `data.ts`, `chat.ts`)
  * `services/` (`shopsService.ts`, `knowledgeService.ts`, `chatService.ts`)
  * `models/` (`shop.ts`, `knowledgeChunk.ts`, `chatLog.ts`)
  * `utils/` (`chunkText.ts`, `detectLanguage.ts`)

---

## ЧАСТЬ 2. База данных и pgvector

**1. Установка pgvector**

В PostgreSQL:

```sql
CREATE EXTENSION IF NOT EXISTS vector;
```

**2. Таблицы**

```sql
CREATE TABLE shops (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  public_key UUID UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE knowledge_chunks (
  id SERIAL PRIMARY KEY,
  shop_id INTEGER REFERENCES shops(id) ON DELETE CASCADE,
  source_type TEXT NOT NULL, -- 'product' | 'faq' | 'policy'
  source_id TEXT,            -- SKU, id вопроса и т.п.
  text TEXT NOT NULL,
  embedding vector(1536),    -- под text-embedding-3-small
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE chat_logs (
  id SERIAL PRIMARY KEY,
  shop_id INTEGER REFERENCES shops(id) ON DELETE CASCADE,
  session_id UUID NOT NULL,
  user_message TEXT NOT NULL,
  assistant_answer TEXT NOT NULL,
  context_used TEXT,
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE surveys (
  id SERIAL PRIMARY KEY,
  shop_id INTEGER REFERENCES shops(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT CHECK (status IN ('draft','active','archived')) DEFAULT 'draft',
  definition JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE survey_responses (
  id SERIAL PRIMARY KEY,
  survey_id INTEGER REFERENCES surveys(id) ON DELETE CASCADE,
  session_id UUID NOT NULL,
  answers JSONB NOT NULL,
  metadata JSONB,
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE widget_events (
  id SERIAL PRIMARY KEY,
  shop_id INTEGER REFERENCES shops(id) ON DELETE CASCADE,
  session_id UUID NOT NULL,
  event_name TEXT NOT NULL,
  metadata JSONB,
  created_at TIMESTAMP DEFAULT now()
);
```

**3. Индексы**

```sql
CREATE INDEX idx_chunks_shop ON knowledge_chunks(shop_id);
CREATE INDEX idx_chunks_embedding ON knowledge_chunks USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
```

---

## ЧАСТЬ 3. Конфиг backend’а

**1. `src/config/env.ts`**

* Чтение:

  * `OPENAI_API_KEY`
  * `DATABASE_URL`
  * `PORT`

**2. `src/config/db.ts`**

* Подключение `pg` к PostgreSQL
* Экспорт пула/клиента

**3. `src/config/openai.ts`**

* Инициализация клиента OpenAI

---

## ЧАСТЬ 4. Модели (TypeScript интерфейсы)

**`src/models/shop.ts`**

* `id`, `name`, `public_key`

**`src/models/knowledgeChunk.ts`**

* `id`, `shop_id`, `source_type`, `source_id`, `text`, `embedding`

**`src/models/chatLog.ts`**

* `id`, `shop_id`, `session_id`, `user_message`, `assistant_answer`, `context_used`

---

## ЧАСТЬ 5. Утилиты

### 5.1. Разбиение текста на чанки

**`src/utils/chunkText.ts`**

* Вход: `text: string`, `maxTokensOrChars: number`
* Логика:

  * разбить по предложениям/переводам строк;
  * собрать фрагменты пока длина < лимита;
  * вернуть массив строк.

### 5.2. Определение языка

**`src/utils/detectLanguage.ts`**

* Простейший вариант:

  * если есть кириллица → `"ru"`
  * иначе → `"en"`

---

## ЧАСТЬ 6. Shops – создание магазина

### 6.1. Сервис

**`src/services/shopsService.ts`**

Функции:

* `createShop(name: string) => { id, public_key }`

  * генерирует `public_key` (UUID)
  * вставка в БД
* `getShopByPublicKey(publicKey: string) => Shop | null`

### 6.2. Роуты

**`src/routes/shops.ts`**

* `POST /api/shops`

  * body: `{ name: string }`
  * вызывает `createShop`
  * возвращает `{ id, public_key }`

---

## ЧАСТЬ 7. Импорт данных магазина (каталог/FAQ)

### 7.1. Формат данных

* `products[]`: `{ id, name, description, price? }`
* `faq[]`: `{ id?, question, answer }`
* `policies[]`: `{ id?, title, content }`

### 7.2. Сервис

**`src/services/knowledgeService.ts`**

Функции:

1. `prepareChunksFromPayload(shopId, payload) => Array<{source_type, source_id, text}>`

   * формирует текст:

     * для продукта: `"Название: ... Описание: ... Цена: ..."`
     * для FAQ: `"Вопрос: ... Ответ: ..."`
     * для политики: `"Название: ... Текст: ..."`
   * прогоняет через `chunkText`.

2. `embedChunk(text: string) => number[]`

   * вызывает OpenAI embeddings (`text-embedding-3-small`)
   * возвращает массив embedding.

3. `saveChunks(shopId, chunksWithEmbeddings)`

   * вставляет в `knowledge_chunks`.

### 7.3. Роут

**`src/routes/data.ts`**

* `POST /api/shops/:shopId/data`

  * body: `{ products, faq, policies }`
  * шаги:

    1. проверить, что shop существует;
    2. вызвать `prepareChunksFromPayload`;
    3. пройтись по чанкам:

       * вызвать `embedChunk`;
       * собрать массив;
    4. `saveChunks`;
    5. вернуть `{ status: "ok", chunks: N }`.

---

## ЧАСТЬ 8. Поиск по базе знаний (RAG)

### 8.1. Сервис

**`src/services/knowledgeService.ts`** (продолжение)

Функция:

* `getRelevantChunks(shopId: number, question: string, limit: number)`

Шаги:

1. Вычислить embedding вопроса через OpenAI.

2. Запрос в БД:

   ```sql
   SELECT text
   FROM knowledge_chunks
   WHERE shop_id = $1
   ORDER BY embedding <-> $2
   LIMIT $3;
   ```

3. Вернуть массив текстов.

---

## ЧАСТЬ 9. Chat-сервис

### 9.1. Сервис

**`src/services/chatService.ts`**

Функции:

1. `buildSystemPrompt(storeName: string): string`

   * возвращает **тот самый большой промпт** (с подстановкой `{{STORE_NAME}}`).

2. `buildContext(chunks: string[]): string`

   * склеивает чанки в текст:

     ```text
     [Фрагмент 1]
     ...

     [Фрагмент 2]
     ...
     ```

3. `callOpenAIChat(systemPrompt, context, userMessage)`

   * формирует `messages`:

     * `{role: "system", content: systemPrompt}`
     * `{role: "system", content: "Контекст...\n" + context}`
     * `{role: "user", content: userMessage}`
   * вызывает OpenAI Chat (`gpt-4.1-mini`)
   * возвращает `answer: string`.

4. `logChat(shopId, sessionId, userMessage, assistantAnswer, contextUsed)`

   * вставка записи в `chat_logs`.

### 9.2. Роут

**`src/routes/chat.ts`**

* `POST /api/chat`

  * body: `{ shopPublicKey, sessionId, message }`
  * шаги:

    1. найти shop по `public_key`;
    2. вызвать `getRelevantChunks(shop.id, message, 5)`;
    3. `buildContext(chunks)`;
    4. `detectLanguage(message)` → для выбора языка (если нужно).
    5. `buildSystemPrompt(shop.name)`;
    6. `callOpenAIChat(systemPrompt, context, message)`;
    7. `logChat(...)`;
    8. вернуть `{ answer }`.

---

## ЧАСТЬ 10. Сборка backend

**`src/index.ts`**

* инициализировать Express;
* middleware:

  * `cors`, `json`;
* подключить роуты:

  * `/api/shops`
  * `/api/shops/:shopId/data`
  * `/api/chat`
* `app.listen(PORT)`.

Скрипты в `package.json`:

```json
"scripts": {
  "dev": "ts-node-dev src/index.ts",
  "build": "tsc",
  "start": "node dist/index.js"
}
```

---

## ЧАСТЬ 3.1. Опросы, ответы и аналитика

**Backend:**

* Роуты `/api/shops/:shopId/surveys` (CRUD опросов) + `/api/shops/public/:publicKey/surveys/active` для виджета.
* `/api/surveys/:surveyId/responses` принимает `{ sessionId, answers, metadata }` и пишет в `survey_responses`.
* `/api/analytics/events` пишет сырые события интерфейса в `widget_events`.
* `/api/analytics/shops/:shopId/summary` агрегирует события (кол-во кликов по кнопкам, среднее время онлайн и т.п.).

**Widget:**

* Автоматически подгружает активный опрос, рендерит карточку, шлёт ответы.
* Отправляет события: `widget_init`, `page_view`, `widget_toggle`, `quick_prompt_click`, `feedback_vote`, `survey_*`, `message_*`, `session_duration`, `page_hidden/page_visible`.
* В метаданных событиях: язык, URL страницы, длительность фокуса, идентификаторы кнопок.

---

## ЧАСТЬ 11. Виджет (frontend-widget)

**1. Структура**

* `frontend-widget/`

  * `widget.js`
  * `widget.css` (можно inline)

**2. `widget.js`**

Функции:

* `initWidget(shopPublicKey)`

  * создать кнопку и окно чата;
  * инициализировать `sessionId` (localStorage).
* `sendMessage(text)`

  * POST на `https://your-domain.com/api/chat`
  * тело: `{ shopPublicKey, sessionId, message: text }`
  * показать ответ.

**3. Публикация виджета**

* Backend должен отдавать `widget.js` как статический файл:

  * либо отдельный nginx,
  * либо Express `express.static`.

**4. Подключение на стороне магазина**

```html
<script src="https://your-domain.com/widget.js"
        data-shop-id="PUBLIC_KEY_ОТ_ТЕБЯ"></script>
```

### Как подключить ассистента к сайту сейчас

1. **Настраиваем backend.** Добавь в `.env` ключи:

   ```env
   OPENAI_API_KEY=sk-...
   OPENAI_MODEL=gpt-4o-mini   # опционально
   OPENAI_BASE_URL=https://api.openai.com/v1   # опционально
   ```

   Перезапусти сервер (`npm run build && npm start` в `backend/`).

2. **Подключаем скрипт на витрину.**

   ```html
   <script
     src="https://your-domain.com/widget.js"
     data-shop-id="PUBLIC_KEY"
     data-api-base="https://your-domain.com"
     data-lang="ru"
   ></script>
   ```

   Дополнительно можно передать `data-prompts='["Где заказ?"]'` и `data-perks='{...}'`.

3. **Забираем лиды.** После каждого ответа OpenAI возвращает `collectedData`. Скрипт выдаёт его в виде события
   `palompy:lead` и через API `window.PalompyWidget.onLead(cb)`:

   ```html
   <script>
     document.addEventListener('palompy:lead', (event) => {
       console.log('Новый лид', event.detail);
       // event.detail: { name, email, phone, intent, orderNumber, preferredContact, notes, sessionId, pageUrl }
     });

     window.PalompyWidget?.onLead?.((lead) => {
       // Можно отправить лид в CRM или аналитику.
     });
   </script>
   ```

4. **Какие данные летят в backend.** Виджет передаёт `sessionId`, язык, сообщение и метаданные (URL и заголовок страницы).
   Это позволяет OpenAI уточнять контактные данные и намерение пользователя, а backend сохраняет их в базе (`chat_logs`).

---

## ЧАСТЬ 12. Мини-админка (опционально на MVP)

**Функции:**

* Форма для создания магазина (вызов `POST /api/shops`).
* Форма для загрузки JSON с данными (вызов `POST /api/shops/:id/data`).
* Простая таблица логов (селект `chat_logs` по shop_id).

Можно сделать:

* либо отдельным SPA на React,
* либо простыми HTML-страницами (Pug/EJS) с формами.

---

## ЧАСТЬ 13. Деплой

**1. Вариант Docker + VPS**

* Файлы:

  * `Dockerfile` для backend
  * `docker-compose.yml` с:

    * `backend`
    * `postgres`
    * (nginx при необходимости)

**2. Настройки:**

* ENV:

  * `OPENAI_API_KEY`
  * `DATABASE_URL`
  * `PORT`
* Nginx:

  * проксировать `/api/*` на backend
  * отдавать `widget.js` и админку как статику.

---

## ЧАСТЬ 14. Проверка и итерации

1. Локально:

   * создать тестовый shop;
   * загрузить тестовый JSON (1–2 товара, FAQ);
   * задать вопрос через утилиту (Postman/curl) → проверить ответ.
2. Встроить виджет в тестовый HTML-магазин.
3. Проверить ответы, подправить:

   * системный промпт,
   * размер чанков,
   * количество чанков в контексте.
4. После — идти к первому реальному магазину на пилот.

---

Если хочешь, следующий шаг — могу расписать **пример JSON для импорта товаров и FAQ**, чтобы ты сразу делал экспорт из любого магазина в нужный формат.
